Пустой объект будет занимать у меня 16 байт, т.к. у меня 64 битная система.
В 32 битной занимал бы 8 байт. Если говорить конкретно об объектах User,
которые я создаю, то:

1. User без инициализации полей:
16 бит - заголовок
4 бита - поле int
4 бита - поле для ссылки String
Итого: 24 бита

2. User с инициализацией полей:
Всё тоже самое, но + ещё для ссылки String:
Заголовок 16 бит
Поля int: 4 байта * 3 == 12 байт
Ссылочная переменная на объект массива: 4 байта
Итого: 32 байта
Массив внутри String:
Заголовок: 16 байт + 4 байта на длину массива == 12 байт
Примитивы char: 2 байта * 1 == 2 байта
Выравнивание для кратности 8 : 2 байта
Итого: 24 байта
Итого всего с инициализацией: 24 + 32 + 24 = 76 бита

У меня получилось добиться, чтобы виртуальная машина сама начала запускать GC.
Для этого пришлось увеличить значения xmx. Для тестов я использовал значения
128 и 256. Так вот для 128 с теми данными, на которых я проверял, буквально 1-2 мб
не хватало, чтобы программа вылетела с нехваткой памяти и в таком случае GC
(по моим подсчетам) сработал 25. Среднее время срабатывание 1 раз в 39 миллисекунд.
Для ключей с значением 256 GC сработал 8 раз. Среднее время срабатывания 1 раз в 96 миллисекунд.
Могу резуюмировать, что уборщик начинает активнее срабатывать, когда "понимает", что память вот-вот
кончится.